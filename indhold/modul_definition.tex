\subsubsection{Forslag til Modulært Lag}
For at kunne vælge et modulært lag som opfylde behovene for arkitekturen(\cref{arkitekturkrav}) er der her givet eksempler på hvordan laget kan se ud.
Hvorefter et valg af hvilket modulært lag der vælges vil blive beskrevet.

\paragraph{Komplet Pakke}
En traditionel applikation samler al funktionalitet i en pakke.
Hvis man udvikler på dele af applikationen vil en opdatering skulle ske af hele appen på samme tid.
Desuden begrænser det eksterne udviklere at bidrage til applikationen, da opdateringer skal ske igennem udviklerne af hovedapplikationen.

\paragraph{Import af Kode}
En anden mulighed er at inkludere et scripting sprog med applikationen og gøre det muligt at udvikle scripts der kan agere modul.
Denne løsning kræver et scripting sprog der kan  stille alle Androids muligheder til rådighed.
Derudover skal scripting sproget også sørge for at der er en nem og sikker måde at kontakt databasen.
Hvis scriptet på den anden side skal skrives direkte i Java vil der være nogle sikkerhedshensyn som vil gøre det svært at kontrollere hvad moduler kan og ikke kan.

\paragraph{Selvstændig Applikation}
Den tredje mulighed er at pakke hvert modul i en selvstændig APK\footnote{Androids pakkeformat} \citep{misc:apk}.
Denne APK skal indeholde en beskrivelsesfil som læses i hoved-applikationen og indeholder information om modulet.

Ulemper ved denne løsning er at den er knap så lightweight, idét at det kræver at en stor mængde af applikationer skal installeres.
Desuden kan det være træls at skulle installere en større mængde af applikationer for at have den fornødne funktionalitet.
Som løsning derpå kunne man med videre arbejde have et indbygget applikation marked i manageren, og er værd at udforske med mere tid.

\subsubsection{Valg af Modulær Lag}
For at vælge den en måde at lave det modulære lag på, er det vigtigt at kigge på de behov der er for arkitekturen.

Løsningen den komplette pakke giver en nem måde at kunne kommunikere mellem moduler på den måde at de kan kontakte hinanden direkte fordi de er i samme pakke.
Dog kommer løsningen med den ulempe at det ikke bliver et modulært system, fordi det ikke bliver muligt at udskifte dele af funktionaliteten hvis ny og bedre teori findes.
Det er i strid med behovet \textit{modulær}, beskrevet i \cref{arkitekturkrav::modulaer}.
Derudover, gør løsningen også så at udviklingen af systemet bliver begrænset, på den måde at det kun er udviklerne af hovedapplikationen der har mulighed for at ændret på systemet.
På grund af disse begrænsninger er denne løsning ikke valgt

Den næste løsning der blev kigget på er import af kode.
Løsningen kræver at man udvikler et scripting sprog der har alle Androids funktionaliteter til rådighed, hvilket er meget tidskrævende.
Denne løsning er dog \textit{modulær}, idet man selv kan vælge hvilke moduler man vil gøre brug af.
Desuden er løsningen også med til at gøre det mere enkelt at udvikle sit eget modul.
Denne løsning er en mulighed der kan benyttes.

Den sidste løsning der er at have selvstændige applikationer.
Ved denne løsning er det muligt, ligesom ved import af kode, at kunne vælge mellem hvilke moduler man vil gøre brug af, hvilket gør denne løsning \textit{modulær}.
Denne løsning har dog den ulempe at det kan give problemer med kommunikationen mellem moduler da de er hver deres applikation, hvilket er i strid med behovet \textit{kommunikation}, beskrevet i \cref{arkitekturkrav::kommunikation}
Dog er dette ikke en stor ulempe på grund af den måde DBAccess er designet.
Eftersom løsningen gør systemet mere modulært og da ulempe ved rørende kommunikation ikke er så stor, er denne også en mulighed der kan benyttes.

Løsningen selvstændige applikationer er valgt fordi at denne løsning er mindre tidskrævende end import af kode.



\subsubsection{Beskrivelse af Modulært Lag}\label{modul_definition}
Her vil den implementerede løsning blive gennemgået.

\paragraph{Typer af Moduler}
Der findes tre typer moduler: \textit{data}, \textit{analyse} og \textit{visualisering}.
Data moduler indsamler data fra smartphonens forskellige sensorer og applikationer.
Endvidere bruger analyse moduler data fra enten data-moduler eller andre analyse-moduler til at bearbejde data med den hensigt at opnå en opsummering af data, som kan videre bruges af systemet til enten visualisering eller videre bearbejdning.
Visualiserings-modulerne bruges til visualisering af den rå sensor-data eller den behandlede analyse-data.

\paragraph{Moduldefinition}
Som minimum har et modul et navn og en version, så andre moduler kan referere dem.

Data- og analyse-moduler skal gøre data tilgængeligt for andre analyse- og visualiserings-moduler.
For at specificere hvordan data skal gemmes, samt hvad der er tilgængeligt for andre, skal dette defineres for hvert data- og analyse-modul.
For hvert modul skal der defineres en eller flere tabeller som modulet kan gemme data i.
For hver tabel defineres en eller flere kolonner med et beskrivende navn, datatype og evt. en måleenhed.

\paragraph{Data Typer}
De tilgængelige data typer tilgængelig for tabel-kolonner, er begrænset til de tilgængelige SQLite datatyper.
Der er 5 typer: \textit{NULL}, \textit{INTEGER}, \textit{REAL}, \textit{TEXT} og \textit{BLOB}.

\paragraph{Afhængigheder}
Et analyse- eller visualiserings-modul kan være afhængigt af andre sensor- eller visualiserings-moduler.
Et analysemodul kan aggregere data fra andre analysemoduler mens et visualiseringsmodul er afhængig af det modul det skal vise data fra.
Derfor skal det defineres for hvert modul hvilke andre moduler det er afhængigt af.
Der findes to grader af afhængigheder i systemet: hard- eller soft-dependency.
En hard-dependency er ét andet modul som det pågældende modul ikke kan fungere uden.
En soft-dependency er en liste af andre moduler, hvor mindst ét af de listede moduler skal være til stede på enheden.
Dette er nyttigt hvis et modul skal bruge eksempelvis accelerometer data, men det er ikke vigtigt om det kommer fra en smartphone eller fra en wearable.

\paragraph{JSON og JSON Schema}
For at have en modul-beskrivelse der er læselig for både mennesker og maskiner, er JSON valgt.
JSON gør det muligt for ikke-tekniske personer at læse, skrive og forstå definitionen af et modul.
For at sikre validiteten af eksternt leverede modul-beskrivelser, er der udarbejdet nogle JSON Schemas, som JSON-dokumenter holdes op imod og derved verificeres.
De anvendte JSON Schemas kan findes i \cref{app:json_schema}.

\subparagraph{Eksempel} Accelerometer modul-definitionen kan ses her.
Meta-data er præfikset med \_ (underscore).
\begin{lstlisting}
{
  "name": "accelerometer",
  "_userfriendlyname": "Accelerometer",
  "_version": 1.0,
  "_description":"Maaler og opbevarer acceleration i tre akser.",
  "tables": [
    {
      "name": "accelerations",
      "columns": [
        { "name": "accX", "dataType": "REAL", "_unit": "g"},
        { "name": "accY", "dataType": "REAL", "_unit": "g"},
        { "name": "accZ", "dataType": "REAL", "_unit": "g"}
      ]
    }
  ]
}
\end{lstlisting}

\paragraph{Implementering}
Som nævnt i \cref{sec:valg_af_android}, implementeres der til Android smartphones.
Dette sætter nogle begrænsninger ift. valg af løsninger.

\subparagraph{JSON kontra XML}
XML ville være det naturlige valg for Android applikationer, da en del af applikations udvikling foregår i XML fordi man ofte bruger det til at definere layouts og definering af statiske ressourcer. 
Dog blev JSON valgt over XML, da vi gerne ville have automatisk generering af en parser ud fra skemaet.
En automatisk genereret parser vil lette arbejdet med et skema der i udviklingsperioden ændres ofte.
Denne automatiske generering viste sig ikke at være ligetil på grund af kompatibilitetsproblemer på Android, mens det var enkelt at udføre i JSON.

\subparagraph{Moduler som Applikationer}
For at det skal være muligt at installere moduler uden at opdatere hoved-applikationen, skal der installeres applikationer via Google Play Store.
Alle modul-applikationer, samt hoved-applikationen, deler \textit{package}-navn.
Hver modul-applikation har sin JSON beskrivelse som en eksternt tilgængelig \textit{ressource}, som hoved-applikationen eller andre moduler har adgang til.
Kommunikation mellem applikationer foregår med \textit{services}, \textit{intents} eller \textit{content provider}.

\subparagraph{Håndtering i Manager}
Håndteringen af moduler sker i manageren, beskrevet i \cref{subsec:arkitektur-Manager}.
Når der tilføjes eller opdateres et modul detekterer manageren dette ved at finde alle applikationer der er installeret under pakken ``dk.aau.cs.psylog''.
Manageren læser alle moduldefinitioner efter at have valideret dem op imod JSON skemaet.
Alle moduler der har opdateret versionsnummer eller er helt nye vil blive håndteret ved at manageren læser tabelinformation ind fra moduldefinitionen og opretter eller ændrer de pågældende tabeller.

Når modulernes tabeller er blevet oprettet bygges en graf over afhængigheder, som bruges til at vise brugeren hvilke moduler der kan aktiveres.
Denne proces er yderligere beskrevet i \cref{sec:settings}
