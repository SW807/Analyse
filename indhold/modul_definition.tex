%Måde at lave eksterne modul-apps uden at ændre hoved-app
%Definere output (tabeller/kolonner), samt input (afhængigheder)
%Evt. konfigurationsmuligheder for moduler afhængige af det
%Fleksibel måde at modtage data fra andre moduler, uden at skulle opdatere app(s). Dvs. ikke design-mønstre: observer, mediator, men gennem content provider.
% modularisering i Android; multiple apps under samme package

For at opfylde kravet om fleksibilitet der er stillet til systemet, har vi udtænkt en modulbaseret arkitektur der gør det let at tilføje moduler til pakken.
Det skal være muligt at tilføje eksterne moduler, uden at have behov for at lave ændringer i hoved-applikationen.
Dette kan gøre sig gældende når der kommer nye sensorer på markedet, eller hvis der skal laves nye former for visualiseringer til det allerede indsamlede data.
\subsubsection{Forslag til modulariseing}
\paragraph{Komplet pakke}
En traditionel app samler al funktionalitet i en pakke.
Hvis man udvikler på dele af applikationen vil en opdatering skulle ske af hele appen på samme tid.
Desuden bliver det sværere for eksterne udviklere at bidrage til applikationen, da opdateringer skal ske igennem udviklerne af hovedapplikationen.

\paragraph{Import af kode}
En anden mulighed er at inkludere et scripting sprog med applikationen og gøre det muligt at udvikle script der kan agere modul.
Denne løsning kræver et meget kraftigt scripting sprog hvis alle Androids muligheder skal stilles til rådighed.
Hvis scripts på den anden side skal skrives direkte i java vil der være nogle sikkerhedshensyn som vil gøre det svært at kontrollere hvad moduler kan og ikke kan.
For eksempel vil det være vanskeligt at kontrollere hvilke database tabeller der er adgang til.
Sikkerhedsproblemet er stort, men kunne sikkert løses med nok tid og ressourcer.

\paragraph{Selvstændig app}
Den tredje mulighed er at pakke hvert modul i en selvstændig APK \footnote{Androids pakkeformat}.
Denne APK skal indeholde en beskrivelsesfil som læses i hoved-applikationen og indeholder information om modulet.
Denne metode sørger for at hoved applikationen kan kontrollere hvad moduler har adgang til. 

Ulemper ved denne løsning er at den er knap så lightweight, idét at det kræver at en stor mængde af apps skal installeres.
Derudover er kommunikation mellem apps vanskeligere end internt i en app, men ses som acceptabelt.
Desuden kan det være træls at skulle installere en større mængde af apps for at have den fornødne funktionalitet.
Som løsning derpå kunne man med videre arbejde have et indbygget app marked i manageren, og er værd at udforske med mere tid.

Det er en løsning der har mange fordele i forhold til modularisering og svagheder der kan tolereres, hvorfor denne løsning er valgt. 

Det følgende vil forklare detaljerne i implementationen af moduler ved hjælp af selvstændige apps.

\subsubsection{Beskrivelsesfilen}

Til dette er der valgt at bruge JavaScript Object Notation (JSON) samt JSON Skema \cite{json_schema}.
Eksemplerne der bruges herefter vil derfor være i henholdsvis JSON eller JSON Skema.

\subsubsection{Typer af moduler}
Der findes som sagt i \cref{sec:arkitektur}, tre typer moduler: \textit{sensor}, \textit{analyse} og \textit{visualisering}.
Som sagt er sensor moduler, moduler som indsamler data fra telefonens forskellige sensorer og applikationer.
Endvidere er analyse moduler, moduler som bruger data fra enten sensor eller andre analyse moduler til at bearbejde data med den hensigt at opnå en opsummering af data som kan videre bruges af systemet til enten visualisering eller videre bearbejdning.
Visualiseringsmodulerne bruges til visualisering af den rå sensor-data eller den behandlede analyse-data.

\subsubsection{Moduldefinition}
Som minimum har et modul et navn og en version, så andre moduler kan referere dem.

Sensor- og analyse-moduler skal gøre data tilrådighed for andre analyse- og visualiserings-moduler.
For at specificere hvordan data skal gemmes, samt hvad der er tilgængeligt for andre, skal dette defineres for hvert modul af førstnævnte typer.
For hvert modul skal der defineres en eller flere tabeller som modulet kan gemme data i.
For hver tabel defineres en eller flere kolonner med et beskrivende navn, datatype og evt. en måleenhed.

\subsubsection{Data typer}
De tilgængelige data typer tilgængelig for tabel-kolonner, er begrænset til de tilgængelige SQLite datatyper.
Der er 5 typer: \textit{NULL}, \textit{INTEGER}, \textit{REAL}, \textit{TEXT} og \textit{BLOB}.

\subsubsection{Afhængigheder}
Et analyse- eller visualiserings-modul kan være afhængigt af andre sensor- eller visualiserings-moduler.
Et analysemodul kan aggregere data fra andre analysemoduler mens et visualiseringsmodul er afhængig af det modul det skal vise data fra.
Derfor skal det defineres for hvert modul hvilke andre moduler det er afhængigt af.
Der findes to grader af afhængigheder i systemet: hard- eller soft-dependency.
En hard-dependency er ét andet modul som det pågældende modul ikke kan fungere uden.
En soft-dependency er en liste af andre moduler, hvor mindst ét af de listede moduler skal være til stede på enheden.
Dette er nyttigt hvis et modul skal bruge eksempelvis accelerometer data, men det er ikke vigtigt om det kommer fra en telefon eller fra en wearable.

\subsubsection{JSON og JSON Schema}
For at have en modul-beskrivelse der er læselig for både mennesker og maskiner, er JSON valgt.
JSON gør det muligt for ikke-tekniske personer at læse, skrive og forstå definitionen af et modul.
For at sikre validiteten af eksternt leverede modul-beskrivelser, udarbejdes der et JSON Skema, som JSON-dokumenter kan holdes op imod og derved verificeres.
Det anvendte JSON Skema kan findes i \cref{app:json_schema}.

\paragraph{Eksempel} på en modul-beskrivelse.
Meta-data er præfikset med \_ (underscore).
\begin{lstlisting}
{
  "name": "accelerometer",
  "_version": 1.0,
  "tables": [
    { "name": "accelerations",
      "columns": [
        { "name": "accX",
          "dataType": "REAL",
          "_unit": "g" },
        { "name": "accY",
          "dataType": "REAL",
          "_unit": "g" },
        { "name": "accZ",
          "dataType": "REAL",
          "_unit": "g" }
      ]}]}
\end{lstlisting}

\subsubsection{Implementering}
Som nævnt i \cref{sec:valg_af_android}, implementeres der til Android telefoner.
Dette sætter nogle begrænsninger ift. valg af løsninger.

\subsubsection{JSON kontra XML}
XML ville være det naturlige valg for Android applikationer, da en del af applikations udvikling foregår i XML fordi man ofte bruger det til at definere layouts og definering af statiske ressourcer. 
Dog blev JSON valgt over XML, da vi gerne ville have automatisk generering af en parser ud fra skemaet.
En automatisk genereret parser vil lette arbejdet med et skema der i udviklingsperioden ændres ofte.
Denne automatiske generering viste sig ikke at være ligetil på grund af kompatibilitetsproblemer på Android, mens det var enkelt at udføre i JSON.

\subsubsection{Moduler som apps}
For at det skal være muligt at installere moduler uden at opdatere hoved-applikationen, skal der installeres apps via Google Play Store.
Alle modul-apps, samt hoved-applikationen, deler \textit{package}-navn.
Hver modul-app har sin JSON beskrivelse som en eksternt tilgængelig \textit{ressource}, som hoved-applikationen eller andre moduler har adgang til.
Kommunikation mellem apps foregår med \textit{services}, \textit{intents} eller \textit{content provider}.

\subsubsection{Håndtering i manager}
Håndteringen af moduler sker i manageren, beskrevet i \cref{subsec:arkitektur-Manager}.
Når der tilføjes eller opdateres et modul detekterer manageren dette ved at finde alle apps der er installeret under pakken ``dk.aau.cs.psylog''.
Manageren læser alle moduldefinitioner efter at have valideret dem op imod JSON skemaet.
Alle moduler der har opdateret versionsnummer eller er helt nye vil blive håndteret ved at manageren læser tabelinformation ind fra moduldefinitionen og opretter eller ændrer de pågældende tabeller.

Når modulernes tabeller er blevet oprettet bygges en graf over afhængigheder, som bruges til at vise brugeren hvilke moduler der kan aktiveres\als{evt. referer til settings arbejdsark}.
